/*
Problem 12: Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

FYI: assuming that when they refer to 'divisors' they actually mean factors (numbers that divide with no remainder)
They are technically not the same as divisor refers to any number that you divide another number by. 
Factors are divisors but not all divisors are factors.
*/

#include <iostream>
#include <math.h>
#include <map>

/*
    Returns true if the number is a prime number
*/
bool IsPrime(int number) {
    if (number <= 3) {
        return (number > 1);   // 2 and 3 is prime
    } else if (((number % 2) == 0) || ((number % 3) == 0)) {
        return false;   // divisible by 2 or 3 not primeFactors
    }

    int i = 5;

    while ((i * i) <= number) {
        if (((number % i) == 0) || ((number % (i + 2)) == 0)) {
            return false;
        }
        i += 6;
    }

    return true;
}

/*
    Returns number of factors for an input number
    @param  num Number to check
    @return Number of factors for specified number
*/
int NumFactors(int num) {
    if (num == 1) { // 1 only has 1 factor
        return 1;
    }

    //prime factorisation - division method
    std::map<int, int> primeFactors;    //key: prime factor, value: exponent

    int tmp = num;

    while (tmp != 1) {
        int i = 2;
        int primeDivisor;

        while (1) { // find smallest prime factor
            if (((tmp % i) == 0) && (IsPrime(i))) {
                primeDivisor = i;
                break;
            }

            i++;
        }

        std::map<int, int>::iterator it = primeFactors.find(primeDivisor);

        if (it != primeFactors.end()) {   // found, iterate exponent
            it -> second += 1;
        } else {    // not found, create pair
            primeFactors.insert(std::pair<int, int>(primeDivisor, 1));
        }

        tmp /= primeDivisor;
    }

    // number of factors = multiply together each (exponent + 1)
    int factors = 1;

    for (const auto& pair : primeFactors) { //ref to avoid copying
        factors *= pair.second + 1; 
    }

    return factors;
}

int main() {
    int factors = 0;
    int triNumIndex = 0;
    int sum = 0;

    while (factors <= 500) {
        triNumIndex++;

        sum+= triNumIndex;

        factors = NumFactors(sum);

        //std::cout << "trinum: " << triNumIndex << " " << sum << " " << factors << std::endl;
    }

    std::cout << "trinum: " << triNumIndex << " " << sum << " " << factors << std::endl;

    return 0;
}